---
layout: post
type: essy
title:  人月神话
author: 立泉
date:   2020-07-03 +0800
description: 
cover: 
categories: essy
---

`DarkMode`是`Google`在`Android Q`中引入的全局`暗黑模式`，与`iOS 13`类似，`Android`也开始拥有系统级的明暗主题开关，每一个App都可以选择启用或关闭`暗黑模式`，或者选择跟随系统的设置，自动在`普通模式`和`暗黑模式`之间切换。

如果在中文社区中搜索`暗黑模式`，会奇怪的发现有很多人完全没有理解`DarkMode`和`Theme`之间的关系，所以我一贯认为，阅读官方文档是学习`Android`最基本、最有效的方式，`Android`团队会把新特性的每一个关键点和相关联的内容写在文档中，他们其实也希望能把自己的工作成果详细且准确的传递给全世界的开发者，里面一般都会包含这些功能的设计思路、适配方式和向前的兼容性方案。很多微妙的细节确实会在社区的观点传递（抄袭）中丢失，所以如果只能看到质量很差的末端“教程”，知其然，而不知其所以然，必定会一头雾水。而所谓的`BUG`，如果清楚的知道自己调用的`API`会对当前组件的生命周期产生什么样的影响，以及如何解决可能由此引起的连锁问题，`BUG`，在某种程度上来说，是不应该存在的，或者，是可以被预期的，再或者，当它出现的时候，能很快反应过来，是哪里出了问题。我们可以调侃自己每天都在写`BUG`，但调侃其实只应该是调侃。

> DarkMode is not a dark theme

`"暗黑模式不是一个暗色主题"`，在`Android Q`之前，`Android`也有一套完整的`Theme`主题机制，可以定义一系列的配色方案来构建不同的`Theme`，其中当然也可以包括暗色的`Theme`，但它和`暗黑模式`具有根本性的区别，简单来说，`普通模式`下，可以包含很多`Theme`，而`暗黑模式`更像是`普通模式`的镜像，它是相对于`普通模式`而言的概念，并不是`Theme`。`普通模式`下的每一个`Theme`都应该在`暗黑模式`下找到对应的映射，所以，`普通模式`和`暗黑模式`都是一系列`Theme`的集合，并且这2个模式之间的`Theme`存在一一对应的映射关系。

# Theme的切换

在`暗黑模式`出现之前，一般使用`<style>`来定义`Theme`，可以在`AndroidManifest`文件中定义`Application`和`Activity`要使用的`Theme`，也可以在`Activity`启动时，动态设定当前`Activity`要使用的`Theme`，来实现更普遍的灵活性。

首先将要使用的一些属性，一般是颜色，抽象出来，定义为通用的`attr`属性

```xml
/values/attrs.xml
<resources>
    <!-- 定义各个Theme都要使用的通用属性 -->
    <attr name="commonTitle" format="color"/>
    <attr name="commonBg" format="color"/>
</resources>
```

定义不同`Theme`下这些属性需要的值，这里以`RED`和`GREEN`两个`Theme`为例

```xml
/values/colors.xml
<resources>
    <!-- 定义RED和GREEN主题下需要用到的值 -->
    <color name="commonTitleRed">#FF0000</color>
    <color name="commonTitleGreen">#00FF00</color>
    <color name="commonBgRed">#7F8FA6</color>
    <color name="commonBgGreen">#7F8FA6</color>
</resources>
```

定义`RED`和`GREEN`主题，并绑定属性和该主题对应的值

```xml
<resources>
    <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

    <!-- 红色主题 -->
    <style name="AppTheme.RED">
        <item name="commonTitle">@color/commonTitleRed</item>
        <item name="commonBg">@color/commonBgRed</item>
    </style>
    <!-- 绿色主题 -->
    <style name="AppTheme.GREEN">
        <item name="commonTitle">@color/commonTitleGreen</item>
        <item name="commonBg">@color/commonBgGreen</item>
    </style>
</resources>
```

在`AndroidManifest`中指定`Application`或`Activity`要使用的`Theme`

```xml
<!-- 指定所有Activity都要使用的Theme -->
<application
    ...
    android:theme="@style/AppTheme">
    <!-- 也可以为单个Activity指定Theme -->
    <activity android:name=".MainActivity"
        android:theme="@style/AppTheme.RED"/>
</application>
```

或者，在`Activity`启动时，动态的指定该`Activity`要使用的`Theme`

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    // 取出保存的用户主题设置
    val theme = dataDao.getTheme()
    // 在Activity创建时，为这个Activity设置对应的Theme
    if (theme == CusTheme.RED) {
        setTheme(R.style.AppTheme_RED)
    } else {
        setTheme(R.style.AppTheme_GREEN)
    }
    // 注意这里设置主题要放在setContentView前面
    setContentView(R.layout.activity_demo)
}
```

要实现根据用户的点击选择动态应用`Theme`也很简单，用户点击后，通知`Activity`重建，并在重建时设置`Theme`即可，应注意由`Activity`的重建可能导致的部分组件状态丢失，和`Fragment`重复创建等问题，它们都和`Activity`在异常状态下的状态保存、恢复机制有关。

```kotlin
// 调用Activity实例的recreate()方法即可通知Activity重建
activity.recreate()
```

# 暗黑模式的切换

