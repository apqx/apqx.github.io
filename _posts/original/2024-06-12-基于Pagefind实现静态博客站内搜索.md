---
layout: post
categories: original
title: "基于Pagefind实现静态博客站内搜索"
author: 立泉
mention: Jekyll React Async
date: 2024-06-12 +0800
description: Jekyll生成的静态博客并不支持站内搜索，以往实现要么使用搜索引擎的site:mudan.me限定站点，要么搭配服务器自建全文搜索服务，但是前者索引更新缓慢，后者则太“重”，总之对于倾向免费托管的静态博客并没有特别好的方案。
cover: 
tags: Code Blog Pagefind 搜索 Jekyll
---

`Jekyll`生成的静态博客并不支持站内搜索，以往实现要么使用搜索引擎的`site:mudan.me`限定站点，要么搭配服务器自建全文搜索服务，但是前者索引更新缓慢，后者则太“重”，总之对于倾向免费托管的静态博客并没有特别好的方案。

直到2022年[Pagefind](https://pagefind.app/){: target="_blank" }出现，它是一个基于`Rust`和`WebAssembly`的轻量级静态搜索工具。先使用其`Terminal`命令扫描站点生成索引文件和对应的检索`API`，所谓“API”其实就是`Wasm`程序提供的`Javascript`函数接口，搜索时只需在`Web`中加载调用它们即可自动访问索引文件从中生成结果。

这种模式只是从浏览器访问云端的静态资源，并不需要通常意义上的“搜索服务器”，而且它的搜索算法也会尽量降低检索文件时传输的数据量来节省带宽。以本博客为例，每次搜索下载的数据甚至低于分段字体，所以不必担心高频访问的问题。

## 索引

生成索引需要先安装`Pagefind`命令行工具，由于是`Node.js`包，所以直接使用`npx`即可:

```sh
# 扫描--site指定的目录，将索引输出到--output-path指定的目录下
# 生成索引耗时数秒，不建议使用某些方式与Jekyll的生成命令绑定
# 只在文章内容变化时手动执行
npx -y pagefind --site _site --output-path npm/pagefind
# 注意此命令并不会清除已有数据，而是覆盖
# 所以每次执行前需要手动删除上次的索引，否则可能会越积越多
```

执行后会在`./npm/pagefind`目录中生成以下内容:

```sh
# 索引分页
|-fragment/
|-index/
# 搜索API
|-pagefind.js
# 默认UI
|-pagefind-ui.js
|-pagefind-ui.css
# 模块化UI
|-pagefind-modular-ui.js
|-pagefind-modular-ui.css
# 其它索引项和Wasm程序文件
...
```

注意到里面有名为`*-ui`的`JS`和`CSS`，它们是`Pagefind`预置的搜索界面，简单几步就能嵌入站点:

```html
<!-- 引入UI资源 -->
<link href="/pagefind/pagefind-ui.css" rel="stylesheet">
<script src="/pagefind/pagefind-ui.js"></script>
<div id="search"></div>
<script>
    // 创建UI插入点
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: true });
    });
</script>
```

`pagefind-ui`大概长这样，搜索结果包含下级标题和摘要，效果很不错。而且关键样式都可以通过`CSS`全局变量自定义，比如背景色对应的是`--pagefind-ui-background`。

![](https://apqx.oss-cn-hangzhou.aliyuncs.com/blog/original/20240612/pagefind-ui.webp){: loading="lazy" class="clickable clickShowOriginalImg" alt="Pagefind" }

至于`pagefind-modular-ui`则是模块化的组件`UI`，搜索框和搜索结果是分开的，可以自由插入到指定位置，配置更加灵活。详细信息参考[这里](https://www.npmjs.com/package/@pagefind/modular-ui){: target="_blank" }。

一般情况下，这些文件应该和博客一起托管到相同位置，但是对于考虑国内访问的海外站点，也可把它们单独放到大陆的服务器或`OSS`上，以达到更快的访问速度。

## 搜索

如果对预置`UI`不满意，可以使用`Pagefind`提供的`JS`函数接口来调用搜索`API`，自行处理搜索逻辑和结果展示。

```ts
// pagefind.js文件URL，我在部署时把它放到了国内OSS上，与主站分离
const pagefindUrl: string = isDebug() ? "/npm/pagefind/pagefind.js" : "https://apqx.***.com/blog/pagefind/pagefind.js"
// 动态加载
const pagefind = await import(pagefindUrl)
// 初始化
pagefind.init()
// 执行搜索，获取结果
const pagefindResult = await this.pagefind.search(key)
```

配合`Material Design`做出的搜索`Dialog`:

![](https://apqx.oss-cn-hangzhou.aliyuncs.com/blog/original/20240612/pagefind-api.webp){: loading="lazy" class="clickable clickShowOriginalImg" alt="Pagefind Material Design" }

注意图中`Tips`，`Pagefind`为实现轻量化是对`单词`建立索引，而它的中文`分词`并不完善，一些人名之类的低频词并不能被正确识别，这个时候可以尝试在单字之间加空格，它会搜索同时包含这些字的结果，匹配准确度显著提升。

## Webpack

如上所述调用搜索`API`很简单，只需要`import`对应的`JS`文件而已，但是在`Webpack`中，`import`的`JS`必须是本地文件且会被直接打包而非运行时动态从指定位置加载，导致搜索`JS`总是不能正确访问到云端索引...这个莫名其妙的问题真的困扰我很久，毕竟不是`Web`开发者，明明按照文档一步步做，结果却一直卡住走不通...`Google`那一长串`Error`翻了好多页才终于找到与之相关的一篇文章。

正确做法仅仅是添加一个`webpackIgnore`注释，告诉`Webpack`不要打包`import`的这个`JS`文件，留到运行时再加载。

```ts
const pagefind = await import(/*webpackIgnore: true*/ pagefindUrl)
```

就是这么简单🙄。