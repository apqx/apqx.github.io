---
layout: post
categories: original
title: "为博客添加站内搜索和暗黑模式"
author: 立泉
mention: Google DarkMode
date: 2021-08-03 +0800
description: 搜索无非2种方案，使用搜索引擎提供的站内搜索服务，或完全自己搭服务器实现搜索。后者更加灵活且不依赖搜索引擎缓慢的索引更新，优势很大，只是有太多前端后端的问题需要解决，暂时不适合我。所以最终选定Google的站内搜索，一来是因为我的博客早就加入到了Google的索引之中，可以直接使用，二来也是一个接触当前“最好搜索引擎”所提供的开发者服务的一个机会。
cover: 
tags: CS Google DarkMode Blog
---

我的博客自2016年创建以来一直使用[Materialize](https://materializecss.com){: target="_blank" }作为网页框架，这个优秀的开源项目实现了符合[Material Design](https://material.io/design){: target="_blank" }规范的几乎所有组件，但因为一些原因在三年前发布`v1.0.0`正式版后就不再更新。而`Material Design`的设计理念本身却在不断进化，从起始时过度强调阴影和层级变得趋向扁平，所以我觉得也是时候切换到一个更现代更有活力的`MD`框架了，翻开新的一页。

我并非`Web`开发者，对`HTML`、`CSS`、`JavaScript`和`NPM`仅仅是浅尝可用，花了些时间，解决了些问题，终于用`Google`的[Material Design Components](https://github.com/material-components/material-components-web){: target="_blank" }重构了这个博客站点。依然继承之前的页面设计，同时削减阴影、增加色彩，使之简洁紧凑而不失淡雅，虽还未达到设想中的完美状态，但以我当前的审美来看，十分还是可以给八分的。

# 站内搜索

[Jekyll](https://jekyllrb.com){: target="_blank" }原生支持给文章添加`tag`，可以轻易的用[Liquid](https://jekyllrb.com/docs/posts/#tags){: target="_blank" }语言获取页面的所有`tag`和标记了该`tag`的文章列表，比如这篇就标记了`CS`、`Google`和`DarkMode`等多个`tag`，点击文章顶部的对应`标签`能看到相关联的文章列表弹窗。但是`tag`毕竟有限，不可能把文章里的每个关键词都设置为`tag`，所以站内搜索自然就是一个非常诱人的功能点了，随着写过的东西越来越多，我有时候也很想知道自己在多少文章中提到过某些相似的内容。

搜索无非2种方案，使用搜索引擎提供的站内搜索服务，或完全自己搭服务器实现搜索。后者更加灵活且不依赖搜索引擎缓慢的索引更新，优势很大，只是有太多前端后端的问题需要解决，暂时不适合我。所以最终选定`Google`的站内搜索，一来是因为我的博客早就加入到了`Google`的索引之中，可以直接使用，二来也是一个接触当前“最好搜索引擎”所提供的开发者服务的一个机会。

了解过`Google`搜索`Tips`的应该都知道，是可以在搜索时指定要搜索的特定网站的。

![](https://apqx.oss-cn-hangzhou.aliyuncs.com/blog/20210803/google_site.webp){: loading="lazy" class="clickable clickShowOriginalImg" alt="google site" }

此外它也提供面向站内搜索的[Programmable Search](https://cse.google.com/cse/all){: target="_blank" }服务，实际上是允许用户创建一个自定义范围的`Google`搜索，甚至可以自定义部分`UI`，也支持把搜索框和搜索结果嵌入到用户自己的网页中。我试着嵌入但发现其组件风格和我的博客相去甚远，而且还存在一些搜索结果不定引起的元素尺寸变化问题，所以虽然我不擅长`Web`编程，踌躇后还是决定手动调用[Google的搜索API](https://developers.google.com/custom-search/v1/introduction){: target="_blank" }而不使用现成的`UI`组件。

![](https://apqx.oss-cn-hangzhou.aliyuncs.com/blog/20210803/google_programmable_search.webp){: loading="lazy" class="clickable clickShowOriginalImg" alt="google programmable search" }

搭配`Material Design`的最终成果还是很不错的，不过调用搜索`API`会产生[每千次5美元](https://developers.google.com/custom-search/docs/overview){: target="_blank"}的费用，这个数字对于访问量本来就很小的站点来说差不多也等于免费了。

![](https://apqx.oss-cn-hangzhou.aliyuncs.com/blog/20210803/google_apqx.webp){: loading="lazy" class="clickable clickShowOriginalImg" alt="google apqx" }

实现过程只是用`JS`把`HTTP`请求到的数据填充到页面上显示出来，唯一要注意的是请求搜索的参数中有一个用作身份验证的`API KEY`，它来自于`Google Cloud Platform`的一个启用了`Custom Search API`的`Project`（搜索服务的账单就是与它绑定的），默认情况下这个`KEY`的权限极大，用它可以控制整个`Project`的行为，所以非常危险。

当我把`KEY`写入到`JS`文件并`Push`到`GitHub Pages`上时立刻就收到了`Google`发来的安全警告邮件：

> We have detected a publicly accessible Google API key associated with the following Google Cloud Platform project: Project JetSnail (id: jetsnail-\*\*\*\*) with API key \*\*\*\*

> We believe that you or your organization may have inadvertently published the affected API key in public sources or on public websites (for example, credentials mistakenly uploaded to a service such as GitHub.)

至于解决方法也很简单，按照提示在`Google Cloud Platform`上限定这个`KEY`只用于搜索就可以了。

# 暗黑模式

我作为`Android`开发者可以很轻松的实现`Android`软件的暗黑模式，但到了不怎么熟悉的`Web`平台，则花了一段时间才理清楚。

最简单直观的方法是使用`prefers-color-scheme: dark`，当用户开启暗黑模式的时候，浏览器会加载这个代码块里定义的暗色主题去覆盖原有的`CSS`属性，但这种方式只能响应系统或浏览器级别的全局主题切换，不能实现仅针对当前网页的暗黑模式，显然不够灵活。

```css
/* 正常的主题配色 */
.title {
    color: black;
}

/* 暗黑模式下的主题配色 */
@media (prefers-color-scheme: dark) {
    .title {
        color: white;
    }
}
```

另一种方法是定义一个表示暗黑主题的`dark`类，然后为需要的`class`和`element`定义叠加了`dark`类之后对应的配色样式，这样在切换暗黑模式时只需要`JS`监听触发事件给`body`添加上`dark`类即可，同时这种方法也适用于切换多种不同配色的主题，如`dark`、`red`、`blue`等。

```css
/* 正常的主题配色 */
.title {
    color: black;
}

/* 当给body加上dark类，则body中所有支持color的element都会加载这里定义的属性 */
.dark {
    color: white;
}

/* 如果有某些类不想使用全局的dark类中的属性，可以单独定义 */
.dark .other-title {
    color: gray;
}
```

监听主题切换按钮的示例：

```js
const THEME_LIGHT = "light";
const THEME_DARK = "dark";
const KEY_THEME = "theme";

// 读取保存的用户主题设置
const savedTheme = localStorage.getItem(KEY_THEME);
console.log("saved theme = " + savedTheme);
const bodyE = document.getElementsByTagName("body")[0];
if (savedTheme == THEME_DARK) {
    bodyE.classList.add("dark");
    showThemeDarkIcon(true);
} else {
    showThemeDarkIcon(false);
}

const btnTheme = document.getElementById("topbar_btn_theme")
if (btnTheme != null) {
    // 监听主题切换按钮点击事件，决定是否给body添加或删除dark类
    btnTheme.addEventListener("click", () => {
        if (bodyE.classList.contains("dark")) {
            bodyE.classList.remove("dark");
            showThemeDarkIcon(false);
            localStorage.setItem(KEY_THEME, THEME_LIGHT);
        } else {
            bodyE.classList.add("dark");
            showThemeDarkIcon(true);
            localStorage.setItem(KEY_THEME, THEME_DARK);
        }
    });
}

// 根据当前主题配色显示主题按钮的图标
function showThemeDarkIcon(dark) {
    const btnTheme = document.getElementById("topbar_btn_theme")
    if (btnTheme == null) return;
    if (dark) {
        btnTheme.innerHTML = "light_mode";
    } else {
        btnTheme.innerHTML = "dark_mode";

    }
}
```

基本实现就是这么简单，只是我在把它与`SASS`和`Material Design Components`组合的过程中遇到了相当多的问题，有的甚至困扰几天都百思不解，过程很曲折，但都能被一一解决，所以当我看到最终的成品时是十分欣慰的。

<video playsinline controls muted loop preload="none" poster="https://apqx.oss-cn-hangzhou.aliyuncs.com/blog/20210803/theme_change_h264_thumb.jpg">
    <!-- chrome不支持h265 -->
    <source src="https://apqx.oss-cn-hangzhou.aliyuncs.com/blog/20210803/theme_change_h264.mp4" type="video/mp4">
</video>

# 新的问题

这样使用一段时间后我发现了一个明显的闪屏现象，即当从一个启用暗色主题的页面进入另一个页面时，浏览器会先加载默认的亮色主题然后再由`JS`驱动切换到暗色主题，两个暗色页面之间的短暂亮色就像“闪了一下”。这个闪屏在本地测试中几乎不出现，而在网络环境不佳的情况下一定会出现。

原因是我把切换主题的`JS`代码放到了外部的`JS`文件中，浏览器加载页面时会先根据获取到的`CSS`或默认的样式渲染页面，然后等待`JS`文件下载完成再执行切换主题的逻辑去加载暗色主题的`CSS`，这个时间差造成了“闪烁”。那么只要消除这个时间差不就好了吗，把切换主题的代码嵌入到静态的`HTML`页面里，使它在页面加载的时候就立即执行主题切换，不用再等，也就不存在闪烁了。

```html
<html>
    <head></head>
    <body>
        <!-- 切换主题的Button -->
        <button id="topbar_btn_theme">Change theme</button>
        <!-- 切换主题的JavaScript -->
        <script>
            function checkTheme() {
                try {
                    const THEME_LIGHT = "light";
                    const THEME_DARK = "dark";
                    const KEY_THEME = "theme";
                    const savedTheme = localStorage.getItem(KEY_THEME);
                    console.log("saved theme = " + savedTheme);
                    // 注意，这里要对body添加class，必须在这个<body></body>里面或之后执行，否则是获取不到body的Element的
                    const bodyE = document.getElementsByTagName("body")[0];
                    if (savedTheme == THEME_DARK) {
                        bodyE.classList.add("dark");
                        showThemeDark(true);
                    } else {
                        showThemeDark(false);
                    }
                    const btnTheme = document.getElementById("topbar_btn_theme")
                    if (btnTheme != null) {
                        // 监听主题切换按钮点击事件，决定是否给body添加或删除dark类
                        btnTheme.addEventListener("click", () => {
                            if (bodyE.classList.contains("dark")) {
                                bodyE.classList.remove("dark");
                                showThemeDark(false);
                                localStorage.setItem(KEY_THEME, THEME_LIGHT);
                            } else {
                                bodyE.classList.add("dark");
                                showThemeDark(true);
                                localStorage.setItem(KEY_THEME, THEME_DARK);
                            }
                        });
                    }
                } catch (e) {
                    console.log("catch e = " + e.message);
                }
            }


            function showThemeDark(dark) {
                const btnTheme = document.getElementById("topbar_btn_theme")
                if (btnTheme == null) return;
                if (dark) {
                    btnTheme.innerHTML = "light_mode";
                } else {
                    btnTheme.innerHTML = "dark_mode";
                }
            }

            // 在body中立即执行Theme切换检查
            checkTheme()
        </script>
    
    <body>
</html>
```

这样其实也解决了另一个问题，当从页面A进入页面B后切换主题再退回页面A，因为这段`JS`代码会在页面A加载时再次执行，就可以检测到页面B修改了主题，并立即应用在页面A上，让整个站点的主题保持一致。