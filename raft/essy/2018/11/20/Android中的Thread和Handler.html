<!DOCTYPE html>
<html>

<head>

  <title>Android中的Thread和Handler</title>
  <!--Import Google Icon Font-->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <!--Import materialize.css-->
  <link type="text/css" rel="stylesheet" href="/css/materialize.css" media="screen,projection" />
  <link type="text/css" rel="stylesheet" href="/css/custom.css" media="screen,projection" />
  <!--Let browser know website is optimized for mobile-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta charset="utf-8" />
  <meta name="theme-color" content="#ee6e73" />
  <link rel="shortcut icon" href="/apqx.ico" />
</head> 

<header>
  <!-- nav-bar -->
  <div class="navbar-fixed">
    <nav>
      <!-- nav-tag -->
      <div class="nav-wrapper container">
        <a href="https://apqx.me" class="brand-logo">APQX</a>
        <a href="#" data-target="nav-mobile" class="sidenav-trigger">
          <i class="material-icons">menu</i>
        </a>
        <ul class="right hide-on-med-and-down clear">
          <li  class="active" >
            <a class="waves-effect waves-effect" href=" /index.html ">随笔</a>
          </li>
          <li >
            <a class="waves-effect waves-effect" href=" /index-share.html ">转载</a>
          </li>
          <li>
            <a class="waves-effect waves-effect modal-trigger" href="#about_me">关于我</a>
          </li>
        </ul>
      </div>
    </nav>
  </div>
  <!-- pop-up-about-me -->
  <div id="about_me" class="modal container">
    <div class="modal-content">
      <center>
        <img height="100px" width="100dx" class="circle responsive-img" src=" /assets/me.jpg " />
      </center>
      <center>
        <h4>APQX</h4>
      </center>
      <p class="flow-text center-align">野生散养攻城狮，努力晋级中</p>
      <div class="collection">
        <a href="https://github.com/apqx" class="collection-item" target="blank">GitHub</a>
        <a href="https://www.facebook.com/apqx.me" class="collection-item" target="blank">Facebook</a>
        <a href="https://weibo.com/u/3288422413" class="collection-item" target="blank">Weibo</a>
        <a href="mailto:changgongapq@gmail.com" class="collection-item" target="blank">changgongapq@gmail.com</a>
      </div>
    </div>
  </div>
  <!-- slide-to-show-nav-tag -->
  <ul id="nav-mobile" class="sidenav clear">
    <li  class="active" >
      <a class="waves-effect waves-red" href=" /index.html ">随笔</a>
    </li>
    <li >
      <a class="waves-effect waves-red" href=" /index-share.html ">转载</a>
    </li>
    <li>
      <a class="waves-effect waves-red modal-trigger" href="#about_me">关于我</a>
    </li>
  </ul>

  <!-- parallax-slid-img -->
  <!-- 索引页面不显示 -->
  
  <div class="parallax-container hide-on-med-and-down">
    <div class="parallax">
      <img src="/assets/androidStudio.png">
    </div>
  </div>
  

</header>

<body class="gray">

  
  <!-- content-card -->
  <div class="container">
    <div class="card-panel hoverable">
      <!-- content -->
   
    <p class="title">Android中的Thread和Handler</p>
    <p class="author">APQX</p>
    <p class="date">2018年11月20日</p>
    <h1 id="前言">前言</h1>

<p>其实，在很长的一段时间里，我并不了解<code class="highlighter-rouge">Handler</code>究竟是如何工作的，在接触<code class="highlighter-rouge">RxJava</code>之前，需要切换线程时，我只是简单的<code class="highlighter-rouge">post(Runnable)</code>，但随着所做项目代码的不断迭代优化，我必须要弄清楚自己用到的每一个组件的执行原理，不然便无法为大项目的代码质量负责。之前在学习和工作中，我都会将笔记和心得记录在<code class="highlighter-rouge">OneNote</code>上，这些纯文本记录容量目前已经达到了57M，我知道，是时候停下来，好好将它们分类整理，用它们来填充我的技术栈，这篇文章只是一个开始，如果我能把一个东西写清楚，可以说，我才真正理解了它。</p>

<h1 id="android中的thread">Android中的Thread</h1>

<h2 id="main-thread">Main Thread</h2>

<p>对Android来说，<code class="highlighter-rouge">Thread</code>即Java线程，当一个App的组件启动时，Android系统会为它创建一个<code class="highlighter-rouge">Linux Process</code>和一个<code class="highlighter-rouge">Execution Thread</code>，默认情况下，此App的所有组件都会运行在这个进程的单一执行线程中，包括UI上产生的各种触控交互事件的分发，所以此线程又被称为<code class="highlighter-rouge">UI Thread</code>和<code class="highlighter-rouge">Main Thread</code>。</p>

<h2 id="calledfromwrongthreadexception">CalledFromWrongThreadException</h2>

<blockquote>
  <p>Only the original thread that created a view hierarchy can touch its views</p>
</blockquote>

<p>Android的UI操作是线程不安全的，这意味着多线程操作UI时可能会出现状态不一致的情况，所以Android强制要求必须在主线程中操作UI，在其它任何线程中操作UI都会抛出<code class="highlighter-rouge">CalledFromWrongThreadException</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override onCreate(savedInstanceState: Bundle?) {
    ...
    // 主线程中操作UI
    tvShow.text = "UI Thread"
    // 当View Tree完成后执行
    tvShow.post{
        Thread{
            // 其它线程中操作UI，抛出CalledFromWrongThreadException
            tvShow.text = "Other Thread"
        }.start()
    }
}
</code></pre></div></div>

<h2 id="anr">ANR</h2>

<p>即<code class="highlighter-rouge">Application Not Responding</code>，应用程序无响应，Android作为手持设备，是通过展示UI的触摸与用户交互的，这些触控事件一旦产生，都会在主线程中进行由<code class="highlighter-rouge">Activity</code>到<code class="highlighter-rouge">View</code>的层层分发，交给对应的处理代码，并在处理完成后，及时刷新UI，这样用户才会感到操作流畅、不卡顿。如果负责分发事件的主线程被阻塞（通常是在主线程中执行耗时操作），则用户点击屏幕后，这些触控事件迟迟不能向下传递，事件处理者就无法获取事件并给出反馈，用户看到的就是，点击了屏幕，无任何反应，App就像卡住了一样，通常，如果阻塞时间大于5秒，Android系统就会弹出<code class="highlighter-rouge">ANR</code>，提醒用户强制关闭程序。</p>

<p>总的来说，在Android中使用线程，必须遵循以下2条规则：</p>

<ul>
  <li>必须在主线程中操作UI</li>
  <li>不能阻塞主线程</li>
</ul>

<h1 id="什么是handler">什么是Handler</h1>

<p>已经知道，Android App需要在工作线程中执行耗时操作，然后切换到主线程刷新UI，这个切换线程的动作就可以使用<code class="highlighter-rouge">Handler</code>实现，实际上，<code class="highlighter-rouge">Handler</code>可以实现将任意线程中的<code class="highlighter-rouge">Message</code>、<code class="highlighter-rouge">Runnable</code>发送到指定的线程中处理。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 创建处理Runnable的Handler
val handler = Handler()
override fun onCreate(savedInstanceState: Bundle?) {
    ...
    Thread{
        // 在工作线程中执行耗时操作
        doSth()
        handler.post{
            // 切换到主线程中刷新UI
            Toast.makeText(this, "Work done", Toast.LENGTH_SHORT).show()
        }
        // view的post的内部实现其实也是Handler
        view.post{
            Toast.makeText(this, "Post from view", Toast.LENGTH_SHORT).show()
        }
    }.start()
}
</code></pre></div></div>

<p>要理解<code class="highlighter-rouge">Handler</code>是如何将<code class="highlighter-rouge">Runnable</code>和<code class="highlighter-rouge">Message</code>发送到另一个线程中的，需要借助<code class="highlighter-rouge">Looper</code>、<code class="highlighter-rouge">MessageQueue</code>和<code class="highlighter-rouge">ThreadLocal</code>，我们从创建Handler的那一刻说起：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 创建Handler时，实际使用的构造器
public Handler(Callback callback, boolean async) {
    // 获取Looper
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            "Can't create handler inside thread " + Thread.currentThread()
            + " that has not called Looper.prepare()");
        }
    // 获取Looper的MessageQueue
    mQueue = mLooper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}
</code></pre></div></div>

<p>在创建<code class="highlighter-rouge">Handler</code>时，它会去获取一个<code class="highlighter-rouge">Looper</code>，并且获取这个<code class="highlighter-rouge">Looper</code>的<code class="highlighter-rouge">MessageQueue</code>，如果获取不到，就会直接抛出异常，那么它要获取的是什么Looper呢，继续看</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Looper.myLooper()方法实现
public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }
</code></pre></div></div>

<p>了解<code class="highlighter-rouge">ThreadLocal</code>就知道，它获取的是此线程私有的<code class="highlighter-rouge">Looper</code>，即这个<code class="highlighter-rouge">Looper</code>是和此线程绑定的，那么这个<code class="highlighter-rouge">Looper</code>有什么作用呢？看一下<code class="highlighter-rouge">Handler.post(Runnable)</code>的实现</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final boolean post(Runnable r) {
    // 将Runnable封装成Message，继续传递
   return  sendMessageDelayed(getPostMessage(r), 0);
}
</code></pre></div></div>

<p>最终调用的是这个</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
        return false;
    }
    // 将Runnable封装的Message，添加到一个Handler持有的MessageQueue中，即从Looper那里获取的Queue
    return enqueueMessage(queue, msg, uptimeMillis);
}
private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        // 将该Handler实例保存到Message中
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
</code></pre></div></div>

<p>可以看到，我们切换线程使用的<code class="highlighter-rouge">Handler.post(Runnable)</code>实际上只是把<code class="highlighter-rouge">Runnable</code>封装成<code class="highlighter-rouge">Message</code>，并添加到一个该<code class="highlighter-rouge">Handler</code>从<code class="highlighter-rouge">Looper</code>那里获取的<code class="highlighter-rouge">MessageQueue</code>中了，那么是谁来从<code class="highlighter-rouge">Queue</code>中取出<code class="highlighter-rouge">Message</code>并处理呢？答案就是<code class="highlighter-rouge">Looper</code>，我们来看2个<code class="highlighter-rouge">Looper</code>的关键方法</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Looper.prepare()
private static void prepare(boolean quitAllowed) {
    // 检查该线程是否已经创建过Looper，一个线程只允许创建一次Looper
    if (sThreadLocal.get() != null) {
        throw new RuntimeException("Only one Looper may be created per thread");
    }
    // 创建该线程私有的Looper
    sThreadLocal.set(new Looper(quitAllowed));
}
// Looper的构造器
private Looper(boolean quitAllowed) {
    // 创建MessageQueue
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
</code></pre></div></div>

<p><code class="highlighter-rouge">Looper.prepare()</code>会检查当前线程是否已经创建过<code class="highlighter-rouge">Looper</code>，没有的话就创建一个新的<code class="highlighter-rouge">Looper</code>并设置为该线程私有，留心的话，其实<code class="highlighter-rouge">Handler</code>构造是时从线程中获取的<code class="highlighter-rouge">Looper</code>就是在这里创建的，<code class="highlighter-rouge">Looper</code>创建时会同时在内部创建一个<code class="highlighter-rouge">MessageQueue</code>，也就是<code class="highlighter-rouge">Handler.post()</code>时用到的那个<code class="highlighter-rouge">Queue</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Looper.loop()，这里只取关键逻辑，完整逻辑请看源码
public static void loop() {
    // 确保已经执行过Looper.prepare()
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    // 获取Looper的MessageQueue
    final MessageQueue queue = me.mQueue;
    // 进入一个阻塞线程的无限循环
    for (;;) {
        Message msg = queue.next(); // might block
        try {
            // 取出Message中保存的Handler实例，即发送该Message的Handler，调用它的相关方法去处理这个Message
            msg.target.dispatchMessage(msg);
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
    }
}
</code></pre></div></div>

<p><code class="highlighter-rouge">Looper.loop()</code>会进入一个无限的等待循环，不断检查<code class="highlighter-rouge">MessageQueue</code>中是否有新的<code class="highlighter-rouge">Message</code>，一旦获取到新的<code class="highlighter-rouge">Message</code>，就取出该<code class="highlighter-rouge">Message</code>在<code class="highlighter-rouge">post()</code>的时候保存的<code class="highlighter-rouge">Handler</code>实例，调用该<code class="highlighter-rouge">Handler</code>的方法来处理这个<code class="highlighter-rouge">Message</code>，这就是整个<code class="highlighter-rouge">Handler.post(Runnable)</code>的执行轨迹，那么最关键的线程切换是怎么完成的呢？需要注意<code class="highlighter-rouge">Looper.prepare()</code>执行时所在的线程，它就是<code class="highlighter-rouge">Runnable</code>事件被处理时所在的线程，这个和线程启用<code class="highlighter-rouge">Looper</code>时有关。</p>

<p>前面提到，<code class="highlighter-rouge">Handler</code>创建时必须要求该线程有<code class="highlighter-rouge">Looper</code>，即执行过<code class="highlighter-rouge">Looper.prepare()</code>，一个典型的创建支持<code class="highlighter-rouge">Looper</code>的线程是这样的</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class CusThread : Thread() {
    lateinit var handler: Handler
    override fun run() {
        Looper.prepare()
        handler = Handler()
        // 阻塞线程，等待处理Handler分发的事件
        Looper.loop()
    }
}
</code></pre></div></div>

<p>实际上，这个线程在创建了<code class="highlighter-rouge">Handler</code>之后，就因为执行<code class="highlighter-rouge">Looper.loop()</code>而阻塞，等待执行<code class="highlighter-rouge">Handler</code>分发的事件，注意到，<code class="highlighter-rouge">Looper.loop()</code>是在该线程中执行的，结合之前的源码分析，通过<code class="highlighter-rouge">Handler</code>发送的<code class="highlighter-rouge">Runnable</code>都会在这个线程中执行，而<code class="highlighter-rouge">Handler.post(Runnable)</code>这个行为可以在其它任意线程中进行，这就实现了，在其它线程中发送事件到指定的线程中处理，即广义上的切换线程。</p>

<p>可以这样使用上面的CusThread</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val thread = CusThread()
thread.start()
...
// 在其它线程中发送事件到CusThread线程中处理
Thread{
    thread.handler.post{
        // 这里的代码就会在CusThread中执行了
    }
}.start()
// 在必要时及时退出Looper.loop()引起的线程阻塞，结束该执行线程
thread.handler.looper.quite()
</code></pre></div></div>

<h1 id="使用handlerthread">使用HandlerThread</h1>

<p>普通的线程必须手动创建<code class="highlighter-rouge">Looper</code>才可以使用<code class="highlighter-rouge">Handler</code>，Android提供了一个默认创建好<code class="highlighter-rouge">Looper</code>的线程实现<code class="highlighter-rouge">HandlerThread</code>，原理和上面的<code class="highlighter-rouge">CusThread</code>大同小异，只是多了一些细节控制，可以这样使用它</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val handlerThread = HandlerThread("")
handlerThread.start()
// 创建Handler时传入指定的Looper，这样它就不会去获取创建线程的Looper
val handler = Handler(handlerThread.looper)
...
// 在其它线程中发送事件到CusThread线程中处理
Thread{
    handler.post{
        // 这里的代码就会在HandlerThread中执行了
    }
}.start()
// 在必要时及时退出Looper.loop()引起的线程阻塞，结束该执行线程
handler.looper.quite()
</code></pre></div></div>

<h1 id="main-thread的特殊性">Main Thread的特殊性</h1>

<p>可能已经注意到，既然创建<code class="highlighter-rouge">Handler</code>时要求该线程必须有<code class="highlighter-rouge">Looper</code>，否则直接抛出异常，那么Android的主线程为什么可以直接创建<code class="highlighter-rouge">Handler</code>，其实，可以创建就说明，这个主线程默认已经创建了<code class="highlighter-rouge">Looper</code>，联想一下，Android App实际上是由事件驱动的，主线程也可以说一直都在“阻塞”（即<code class="highlighter-rouge">Looper.loop()</code>），它在等待新的事件进行处理，所谓的“不能阻塞主线程”，实际指的是，不能阻塞主线程中的事件处理，体会一下区别，很有意思的。</p>
 
      
  
      <!-- content -->
    </div>
  </div>
  
  
  <!-- float-btn -->
  <div class="fixed-action-btn" style="bottom: 45px; right: 24px;">
    <a class="btn-floating btn-large waves-effect waves-light green" href="#">
      <i class="material-icons">arrow_upward</i>
    </a>
  </div>

  <footer class="page-footer ">
  <div class="footer-copyright">
    <div class="container">
      Based on
      <a class="orange-text text-lighten-3" target="blank" href="https://materializecss.com">Materialize</a> and 
      <a class="orange-text text-lighten-3" target="blank" href="https://jekyllrb.com/">Jekyll</a>
    </div>
  </div>
</footer>

  <!--Import jQuery before materialize.js-->
  <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script type="text/javascript" src=" /js/materialize.js "></script>
  <script type="text/javascript" src=" /js/init.js "></script>
  <script type="text/javascript" src=" /codeHighLight/highlight.pack.js "></script>
  <link rel="stylesheet" href=" /codeHighLight/styles/darcula.css ">
</body>

</html>